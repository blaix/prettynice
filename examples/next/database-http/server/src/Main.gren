module Main exposing (main)

import HttpClient
import Init
import Json.Encode as Encode
import Json.Decode as Decode
import Node exposing (Environment)
import Prettynice
import Prettynice.Request exposing (Request)
import Prettynice.Response as Response exposing (Response)
import Task exposing (Task)
import Transmutable.Html as H exposing (Html)
import Transmutable.Html.Attributes as A


type alias User =
    { id : Int
    , name : String
    }


type alias Context =
    { httpPerm : HttpClient.Permission
    }


main : Prettynice.Router Context
main =
    Prettynice.defineRouter
        { init = init
        , router = router
        }


init : Environment -> Prettynice.RouterInit Context
init env =
    Init.await HttpClient.initialize <| \httpPerm -> 
        Prettynice.startRouter
            { host = "127.0.0.1"
            , port_ = 3000
            , env = env
            , context = { httpPerm = httpPerm }
            }


router : Context -> Request -> Response -> Task Never Response
router context request response =
    case request.path of
        [] ->
            response
                |> Response.withHtml viewHome
                |> Task.succeed

        [ "users", userId ] ->
            userId
                |> decodeUserId
                |> getUser context.httpPerm
                |> Task.map (getUserSuccess response)
                |> Task.onError (getUserError response)

        _ ->
            response
                |> notFound
                |> Task.succeed


getUserSuccess : Response -> HttpClient.Response (Array User) -> Response
getUserSuccess response getUserResponse =
    case getUserResponse.data of
        [ user ] ->
            Response.withHtml (viewUser user) response

        _ ->
            notFound response


getUserError : Response -> HttpClient.Error (Array User) -> Task Never Response
getUserError response error =
    response
        -- In a real app you will want to handle this without debug
        |> Response.withText (Debug.toString error)
        |> Response.withStatus 500
        |> Task.succeed


getUser : 
    HttpClient.Permission 
    -> Int 
    -> Task 
        (HttpClient.Error (Array User))
        (HttpClient.Response (Array User))
getUser httpPerm userId =
    HttpClient.post "http://localhost:8080/dev"
        |> HttpClient.withJsonBody (userQuery userId)
        |> HttpClient.expectJson decodeUserResponse
        |> HttpClient.send httpPerm


userQuery : Int -> Encode.Value
userQuery userId =
    -- See https://germ.gitbook.io/ws4sqlite/documentation/requests
    -- We want a request that looks like this:
    --     { 
    --         "transaction": [
    --             {
    --                 "query": "select * from User where id = ?",
    --                 "values": [ userId ]
    --             }
    --         ]
    --     }
    Encode.object
        [ { key = "transaction"
          , value = Encode.array Encode.object
            [ [ { key = "query"
                , value = Encode.string "select * from User where id = ?"
                }
              , { key = "values"
                , value = Encode.array Encode.int [ userId ]
                }
              ]
            ]
          }
        ]


decodeUserId : String -> Int
decodeUserId userId =
    userId
        |> String.toInt
        |> Maybe.withDefault 0


decodeUserResponse : Decode.Decoder (Array User)
decodeUserResponse =
    -- See https://germ.gitbook.io/ws4sqlite/documentation/responses
    -- We will get a response that looks like this:
    --     {
    --         "results": [
    --             {
    --                 ...
    --                 "resultSet": [
    --                     { "id": 1, "name": "Justin" }
    --                 ]
    --             }
    --          ]
    --     }
    Decode.map Array.flatten <|
        Decode.field "results" <|
            Decode.array <|
                Decode.field "resultSet" <|
                    Decode.array <|
                        Decode.map2 makeUser
                            (Decode.field "id" Decode.int)
                            (Decode.field "name" Decode.string)


makeUser : Int -> String -> User
makeUser id name =
    { id = id, name = name }


viewUser : User -> { title : String, head : Array (Html msg), body : Array (Html msg) }
viewUser user =
    { title = "User Details"
    , head = []
    , body = 
        [ H.p []
            [ H.text (String.fromInt user.id)
            , H.text ": "
            , H.text user.name
            ]
        , H.p []
            [ H.a [ A.href "/" ]
                [ H.text "Home" ]
            ]
        ]
    }


viewHome : { title : String, head : Array (Html msg), body : Array (Html msg) }
viewHome =
    { title = "Home"
    , head = []
    , body =
        [ H.ul []
            [ H.li []
                [ H.a
                    [ A.href "/users/1" ]
                    [ H.text "user 1" ]
                ]
            , H.li []
                [ H.a
                    [ A.href "/users/2" ]
                    [ H.text "user 2" ]
                ]
            , H.li []
                [ H.a
                    [ A.href "/users/3" ]
                    [ H.text "user 3" ]
                ]
            ]
        ]
    }


notFound : Response -> Response
notFound response =
    response
        |> Response.withStatus 404
        |> Response.withText "not found"
