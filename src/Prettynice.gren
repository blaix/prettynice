module Prettynice exposing 

    -- Routers
    ( Router
    , RouterInit
    , defineSimpleRouter
    , defineRouter
    , startRouter
    , startSimpleRouter

    -- Programs
    , Program
    , ProgramInit
    , defineProgram
    , startProgram
    )

 
{-| Define and start your web server as a router or a full program.

A router is stateless and simply responds to incoming requests with a response.
It comes in two flavors:

* [`defineSimpleRouter`](#defineSimpleRouter): given a [request](Prettynice.Request.Request), return a [response](Prettynice.Response.Response)
* [`defineRouter`](#defineRouter): similar, but your response can depend on tasks (e.g. reading a file or making an HTTP call).

If you need more control, you can define a full program (TODO: write and link to application section of book):

* [`defineProgram`](#defineProgram): Define a webserver as a full program with long-lived state, the ability to respond to messages, and listen to subscriptions

In all cases, your application should define a `main` function that returns the result of one of the `define` functions.
And the required `init` function should return the result of one of the `start` functions from this module.

See the following examples:

(TODO: update examples to use the three flavors and link to an example for each one here)

* simple router example
* router example
* program example

## Routers

@docs Router, RouterInit, defineSimpleRouter, defineRouter, startSimpleRouter, startRouter

## Programs

@docs Program, ProgramInit, defineProgram, startProgram

-}

import FileSystem
import HttpServer as Http exposing (ServerError(..), Method(..))
import HttpServer.Response as HttpResponse 
import Init
import Node exposing (Environment, Program)
import Prettynice.Request exposing (Request)
import Prettynice.Response exposing (Response)
import Server.Static as Static exposing (Mode(..))
import Stream exposing (Stream)
import Task exposing (Task)
import Transmutable.Html as H
import Transmutable.Html.Attributes as A
import Url exposing (Url)


type alias Model appModel =
    { server : Maybe Http.Server
    , stdout : Stream
    , stderr : Stream
    , host : String
    , port_ : Int
    , env : Environment
    , fsPermission : FileSystem.Permission
    , appModel : appModel
    }


-- DEFINITIONS


{-| The definition of your Prettynice router.
-}
type alias Router context =
    Node.Program (Model context) (Msg context {})


{-| The definition of your Prettynice program.
-}
type alias Program appModel appMsg =
    Node.Program (Model appModel) (Msg appModel appMsg)


{-| Init task for starting your Prettynice router.
-}
type alias RouterInit context =
    Init.Task { model : Model context, command : Cmd (Msg context {}) }


{-| Init task for starting your Prettynice program.
-}
type alias ProgramInit appModel appMsg =
    Init.Task { model : Model appModel, command : Cmd (Msg appModel appMsg) }


{-| Define a simple router.

The router is stateless and cannot trigger effects.
-}
defineSimpleRouter :
    { init : Environment -> RouterInit {}
    , router : Request -> Response -> Response
    } -> Router {}
defineSimpleRouter app =
    let
        router _ request response =
            app.router request response
                |> Task.succeed
    in
    defineRouter 
        { init = app.init
        , router = router
        }


{-| Define a router that can depend on tasks.

TODO: link to example
-}
defineRouter :
    { init : Environment -> RouterInit context
    , router : context -> Request -> Response -> Task Never Response
    } -> Router context
defineRouter app =
    Node.defineProgram
        { init = app.init
        , update = update (RouterUpdate app.router)
        , subscriptions = subscriptions (\_ -> Sub.none)
        }


{-| Define a Prettynice program.

If you don't need the full model/update/view cycle,
you probably want a [router](#defineRouter) or [simple router](#defineSimpleRouter) instead.

TODO: link to example
-}
defineProgram :
    { init : Environment -> ProgramInit appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , onRequest : Request -> Response -> appMsg
    } -> Program appModel appMsg
defineProgram app =
    Node.defineProgram
        { init = app.init
        , update = update (ProgramUpdate { appUpdate = app.update, onRequest = app.onRequest })
        , subscriptions = subscriptions app.subscriptions
        }


-- STARTUP

{-| Start your simple router.

This creates the init task you can return from your `init` function.

TODO: link to example
-}
startSimpleRouter :
   { host : String
   , port_ : Int
   , env : Environment
   } -> RouterInit {}
startSimpleRouter config =
    startRouter
        { host = config.host
        , port_ = config.port_
        , env = config.env
        , context = {}
        }

{-| Start your router.

This creates the init task you can return from your `init` function.

You can wrap this in an [Init.await](TODO: link)
if you need to [initialize any subsystems](TODO: link).

TODO: link to example
-}
startRouter :
   { host : String
   , port_ : Int
   , env : Environment
   , context : context
   } -> RouterInit context
startRouter config =
    Init.await Http.initialize <| \serverPermission ->
        Init.await FileSystem.initialize <| \fsPermission ->
            Node.startProgram
                { model =
                    { server = Nothing
                    , stdout = config.env.stdout
                    , stderr = config.env.stderr
                    , host = config.host
                    , port_ = config.port_
                    , env = config.env
                    , fsPermission = fsPermission
                    , appModel = config.context
                    }
                , command =
                    Task.attempt CreateServerResult <|
                        Http.createServer serverPermission
                            { host = config.host
                            , port_ = config.port_
                            }
                }


{-| Start your server program.

This creates the init task you can return from your `init` function.

You can wrap this in an [Init.await](TODO: link)
if you need to [initialize any subsystems](TODO: link).

TODO: link to example
-}
startProgram :
    { host : String
    , port_ : Int
    , env : Environment
    , model : appModel
    , command : Cmd appMsg
    } -> ProgramInit appModel appMsg
startProgram config =
    Init.await Http.initialize <| \serverPermission ->
        Init.await FileSystem.initialize <| \fsPermission ->
            Node.startProgram
                { model =
                    { server = Nothing
                    , stdout = config.env.stdout
                    , stderr = config.env.stderr
                    , host = config.host
                    , port_ = config.port_
                    , env = config.env
                    , appModel = config.model
                    , fsPermission = fsPermission
                    }
                , command =
                    Cmd.batch
                        [ Cmd.map MsgToApp config.command
                        , Task.attempt CreateServerResult <|
                            Http.createServer serverPermission
                                { host = config.host
                                , port_ = config.port_
                                }
                        ]
                }


-- UPDATE


type Msg appModel appMsg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest Http.Request HttpResponse.Response
    | ProgramResponseReady (Cmd appMsg)
    | RouterResponseReady Response
    | MsgToApp appMsg


type AppUpdate appModel appMsg
    = RouterUpdate 
        (appModel -> Request -> Response -> Task Never Response)
    | ProgramUpdate 
        { onRequest : Request -> Response -> appMsg
        , appUpdate : appMsg -> appModel -> 
            { model : appModel
            , command : Cmd appMsg
            }
        }

update : 
    AppUpdate appModel appMsg
    -> Msg appModel appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
update appUpdate msg model =
    case msg of
        CreateServerResult result ->
            case result of
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stdout <|
                                "Server started on http://" ++ model.host ++ ":" ++ String.fromInt model.port_
                    }
                Err (ServerError code message) ->
                    { model = model
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stderr <|
                                "Server failed to start: " ++ code ++ "\n" ++ message
                    }
        
        GotRequest req res ->
            let
                request = 
                    Prettynice.Request.new req

                response =
                    Prettynice.Response.new res

                tryStaticResponse =
                    req.url
                        |> Static.response
                            { fileSystemPermission = model.fsPermission
                            , httpResponse = res
                            , directory = "./dist/client"
                            , mode = Normal
                            }
                        |> Task.map Prettynice.Response.new
                        |> logSuccess model.stdout req "sending static file"
            in
            case appUpdate of
                RouterUpdate router ->
                    let
                        routerResponse =
                            router model.appModel request response
                                |> logSuccess model.stdout req "sending to router"
                    in
                    { model = model
                    , command =
                        tryStaticResponse
                            |> Task.onError (\_ -> routerResponse)
                            |> Task.perform RouterResponseReady
                    }

                ProgramUpdate program ->
                    let
                        appMsg =
                            program.onRequest request response

                        { model = programModel, command = programCmd } =
                            program.appUpdate appMsg model.appModel

                        programCmdTask =
                            programCmd
                                |> Task.succeed
                                |> logSuccess model.stdout req "sending to program"
                    in
                    { model = { model | appModel = programModel }
                    , command =
                        tryStaticResponse
                            |> Task.map Prettynice.Response.send
                            |> Task.onError (\_ -> programCmdTask)
                            |> Task.perform ProgramResponseReady
                    }

        RouterResponseReady response ->
            { model = model
            , command = Prettynice.Response.send response
            }

        ProgramResponseReady cmd ->
            { model = model
            , command = Cmd.map MsgToApp cmd
            }

        MsgToApp appMsg ->
            case appUpdate of
                RouterUpdate _ ->
                    -- router can't receive messages
                    { model = model
                    , command = Cmd.none
                    }

                ProgramUpdate up ->
                    let
                        appUpdateReturn =
                            up.appUpdate appMsg model.appModel
                    in
                    { model = { model | appModel = appUpdateReturn.model }
                    , command = Cmd.map MsgToApp appUpdateReturn.command
                    }


{-| Log a request with a custom message if task succeeds.
-}
logSuccess : Stream -> Http.Request -> String -> Task x a -> Task x a
logSuccess stream request message task =
    let
        printMsg =
            Http.requestInfo request ++ " : " ++ message
                |> Stream.sendLine stream
    in
    task
        |> Task.andThen
            (\a ->
                printMsg
                    |> Task.map (\_ -> a)
            )


-- SUBS


subscriptions : (appModel -> Sub appMsg) -> Model appModel -> Sub (Msg appModel appMsg)
subscriptions appSubs model =
    case model.server of
        Just server ->
            Sub.batch
                [ Http.onRequest server GotRequest
                , Sub.map MsgToApp <| appSubs model.appModel
                ]

        Nothing ->
            Sub.none
