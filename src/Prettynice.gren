module Prettynice exposing 
    ( Program
    , Init
    , defineProgram
    , defineProgramRecord
    , startProgram
    , startProgramRecord
    )

 
{-| Full stack web framework for Gren.

This module mainly provides the functions to define and start your web server.
Prettynice also has the concept of client-side components, and other APIs for common web needs.
For an overview of full functionality, see [the project README](https://github.com/blaix/prettynice?tab=readme-ov-file#pretty-nice-framework),
the [documentation site](https://prettynice.dev),
and the [examples](https://github.com/blaix/prettynice/tree/main/examples).

## Define and Start a Prettynice Server

@docs Program, defineProgram, Init, startProgram

## More Control

If you want total control over how your app is defined and started,
or guarantees that Prettynice only has access to the subsystem permissions you provide,
you can use these functions and pass the resulting records to
[Node.defineProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#defineProgram)
and [Node.startProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#startProgram) yourself.

@docs defineProgramRecord, startProgramRecord

-}

import FileSystem
import HttpServer as Http exposing (ServerError(..), Method(..))
import HttpServer.Response as HttpResponse 
import Init
import Node exposing (Environment, Program)
import Prettynice.Request exposing (Request)
import Prettynice.Response exposing (Response)
import Server.Static as Static exposing (Mode(..))
import Stream exposing (Stream)
import Task exposing (Task)
import Transmutable.Html as H
import Transmutable.Html.Attributes as A
import Url exposing (Url)


type alias Model appModel =
    { server : Maybe Http.Server
    , stdout : Stream
    , stderr : Stream
    , host : String
    , port_ : Int
    , env : Environment
    , fsPermission : FileSystem.Permission
    , appModel : appModel
    }


{-| The definition of your Prettynice program.
-}
type alias Program appModel appMsg =
    Node.Program (Model appModel) (Msg appModel appMsg)


{-| Init task for starting your Prettynice program.
-}
type alias Init appModel appMsg =
    Init.Task { model : Model appModel, command : Cmd (Msg appModel appMsg) }


{-| Define a Prettynice program.

Programs are defined similar to [regular gren node applications](https://gren-lang.org/book/applications/node/)
but with the addition of a `router` function that handles requests.

If you don't want Prettynice to define your program for you,
or you want more control over how your program is defined,
see (Prettynice.defineProgramRecord)[#defineProgramRecord].
-}
defineProgram :
    { init : Environment -> Init appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> Program appModel appMsg
defineProgram app =
    Node.defineProgram <|
        defineProgramRecord app


{-| Create a record that can be passed to [Node.defineProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#defineProgram)
to define a Prettynice program. For example:

    main =
        Node.defineProgram <|
            Prettynice.defineProgramRecord
                { init = init
                , update = update
                , subscriptions = subscriptions
                , router = router
                }

This is a more explicit alternative to (Prettynice.defineProgram)[#defineProgram].
-}
defineProgramRecord :    
    { init : Environment -> Init appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> 
    { init : Environment -> Init appModel appMsg
    , update : Msg appModel appMsg -> Model appModel -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
    , subscriptions : Model appModel -> Sub (Msg appModel appMsg)
    }
defineProgramRecord app =
    { init = app.init
    , update = update { router = app.router, update = Just app.update }
    , subscriptions = subscriptions app.subscriptions
    }


{-| Start a Prettynice program that was defined with [defineProgram](#defineProgram).

This creates the init task you can return from your `init` function.

You can wrap this in an [Init.await/awaitTask](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Init#await)
if you need to run a task or initialize any subsystems before starting.

If you don't want Prettynice to start your program for you,
or you want more control over how your program is started,
see (Prettynice.startProgramRecord)[#startProgramRecord].
-}
startProgram :
    { host : String
    , port_ : Int
    , env : Environment
    , model : appModel
    , command : Cmd appMsg
    } -> Init appModel appMsg
startProgram config =
    Init.await Http.initialize <| \serverPermission ->
    Init.await FileSystem.initialize <| \fsPermission ->
        Node.startProgram <|
            startProgramRecord
                { env = config.env
                , host = config.host
                , port_ = config.port_
                , model = config.model
                , command = config.command
                , permissions =
                    { fileSystem = fsPermission
                    , server = serverPermission
                    }
                }


{-| Create a record that can be passed to [Node.startProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#startProgram)
to start a Prettynice program. For example:


    init env =
        Init.await FilesSystem.initialize <| \fsPermission ->
        Init.await HttpServer.initialize <| \serverPermission ->
            Node.startProgram <|
                Prettynice.startProgramRecord
                    { env = env
                    , host = "localhost"
                    , port_ = 3000
                    , model = {}
                    , command = Cmd.none
                    , permissions =
                        { server = serverPermission
                        , fileSystem = fsPermission
                        }
                    }


This is a more explicit alternative to (Prettynice.startProgram)[#startProgram]
and a way to guarantee Prettynice only has access to the subsystems you are explicitly providing.
-}
startProgramRecord :
    { host : String
    , port_ : Int
    , env : Environment
    , model : appModel
    , command : Cmd appMsg
    , permissions :
        { fileSystem : FileSystem.Permission
        , server : Http.Permission
        }
    } ->
    { model : Model appModel
    , command : Cmd (Msg appModel appMsg)
    }
startProgramRecord config =
    { model =
        { server = Nothing
        , stdout = config.env.stdout
        , stderr = config.env.stderr
        , host = config.host
        , port_ = config.port_
        , env = config.env
        , appModel = config.model
        , fsPermission = config.permissions.fileSystem
        }
    , command =
        Cmd.batch
            [ Cmd.map MsgToApp config.command
            , Task.attempt CreateServerResult <|
                Http.createServer config.permissions.server
                    { host = config.host
                    , port_ = config.port_
                    }
            ]
    }


-- UPDATE


type Msg appModel appMsg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest Http.Request HttpResponse.Response
    | ResponseReady Response
    | MsgToApp appMsg


type alias AppUpdate appModel appMsg =
    appMsg -> appModel -> { model : appModel, command : Cmd appMsg }


update : 
    { router : appModel -> Request -> Response -> Task Never Response
    , update : Maybe (AppUpdate appModel appMsg)
    }
    -> Msg appModel appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
update appUpdate msg model =
    case msg of
        CreateServerResult result ->
            case result of
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stdout <|
                                "Server started on http://" ++ model.host ++ ":" ++ String.fromInt model.port_
                    }
                Err (ServerError code message) ->
                    { model = model
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stderr <|
                                "Server failed to start: " ++ code ++ "\n" ++ message
                    }
        
        GotRequest req res ->
            let
                request = 
                    Prettynice.Request.new req

                response =
                    Prettynice.Response.new res

                appResponseTask =
                    appUpdate.router model.appModel request response
                        |> logSuccess model.stdout req "sending to router"

                tryStaticResponse =
                    req.url
                        |> Static.response
                            { fileSystemPermission = model.fsPermission
                            , httpResponse = res
                            , directory = "./dist/client"
                            , mode = Normal
                            }
                        |> Task.map Prettynice.Response.new
                        |> logSuccess model.stdout req "sending static file"
            in
            { model = model
            , command =
                tryStaticResponse
                    |> Task.onError (\_ -> appResponseTask)
                    |> Task.perform ResponseReady
            }

        ResponseReady response ->
            { model = model
            , command = 
                response
                    |> Prettynice.Response.unwrap
                    |> HttpResponse.send
            }

        MsgToApp appMsg ->
            case appUpdate.update of
                Nothing ->
                    -- non-programs can't receive messages
                    { model = model
                    , command = Cmd.none
                    }

                Just up ->
                    let
                        appUpdateReturn =
                            up appMsg model.appModel
                    in
                    { model = { model | appModel = appUpdateReturn.model }
                    , command = Cmd.map MsgToApp appUpdateReturn.command
                    }


{-| Log a request with a custom message if task succeeds.
-}
logSuccess : Stream -> Http.Request -> String -> Task x a -> Task x a
logSuccess stream request message task =
    let
        printMsg =
            Http.requestInfo request ++ " : " ++ message
                |> Stream.sendLine stream
    in
    task
        |> Task.andThen
            (\a ->
                printMsg
                    |> Task.map (\_ -> a)
            )


-- SUBS


subscriptions : (appModel -> Sub appMsg) -> Model appModel -> Sub (Msg appModel appMsg)
subscriptions appSubs model =
    case model.server of
        Just server ->
            Sub.batch
                [ Http.onRequest server GotRequest
                , Sub.map MsgToApp <| appSubs model.appModel
                ]

        Nothing ->
            Sub.none
