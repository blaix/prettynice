module Prettynice.Props.Encode exposing (encoder)

import Json.Encode
import Prettynice.Props.Parser as Parser exposing (ParsedType, TypeDefinition(..), RecordField, CustomVariant, FieldType(..))


encoder : String -> String
encoder sourceCode =
    when Parser.parseTypeDefinitions sourceCode is
        Ok typeDefs ->
            when Parser.findPropsType typeDefs is
                Just propsType ->
                    let
                        referencedTypes = findReferencedTypes propsType.definition typeDefs
                        allEncoders = Array.map (generateEncoder_ typeDefs) (Array.pushFirst propsType referencedTypes)
                        encoderStrings = Array.map (\encoder_ -> encoder_ ++ "\n\n") allEncoders
                    in
                    String.join "" encoderStrings

                Nothing ->
                    "-- No Props type found in: " ++ Debug.toString typeDefs

        Err deadEnds ->
            "-- Parse error: " ++ Debug.toString deadEnds


generateEncoder_ : Array ParsedType -> ParsedType -> String
generateEncoder_ allTypes typeDefinition =
    let
        encoderName = "encode" ++ typeDefinition.name
        typeName = typeDefinition.name
        
        encoderBody = 
            when typeDefinition.definition is
                TypeAlias aliasedType ->
                    generateTypeEncoder (String.toLower typeName) aliasedType allTypes
                
                RecordAlias fields ->
                    generateRecordEncoder (String.toLower typeName) fields allTypes
                
                CustomType variants ->
                    generateCustomTypeEncoder (String.toLower typeName) variants allTypes
    in
    encoderName ++ " : " ++ typeName ++ " -> Json.Encode.Value\n" ++
    encoderName ++ " " ++ String.toLower typeName ++ " =\n" ++
    "    " ++ encoderBody


findReferencedTypes : TypeDefinition -> Array ParsedType -> Array ParsedType
findReferencedTypes typeDefinition allTypes =
    let
        referencedTypeNames = collectTypeNames typeDefinition
        findTypeByName name = Array.findFirst (\def -> def.name == name) allTypes |> Maybe.map .value
    in
    Array.foldl (\name acc ->
        when findTypeByName name is
            Just foundType -> Array.pushLast foundType acc
            Nothing -> acc
    ) [] referencedTypeNames


collectTypeNames : TypeDefinition -> Array String
collectTypeNames typeDefinition =
    when typeDefinition is
        TypeAlias fieldType ->
            collectFieldTypeNames fieldType
        
        RecordAlias fields ->
            Array.foldl (\field acc -> 
                Array.append acc (collectFieldTypeNames field.fieldType)
            ) [] fields
        
        CustomType variants ->
            Array.foldl (\variant acc ->
                when variant.argument is
                    Just argType -> Array.append acc (collectFieldTypeNames argType)
                    Nothing -> acc
            ) [] variants


collectFieldTypeNames : Parser.FieldType -> Array String
collectFieldTypeNames fieldType =
    when fieldType is
        Parser.StringType -> []
        Parser.IntType -> []
        Parser.FloatType -> []
        Parser.BoolType -> []
        Parser.ArrayType innerType -> collectFieldTypeNames innerType
        Parser.CustomFieldType typeName -> [typeName]
        Parser.RecordType fields -> 
            Array.foldl (\field acc -> 
                Array.append acc (collectFieldTypeNames field.fieldType)
            ) [] fields


generateRecordEncoder : String -> Array RecordField -> Array ParsedType -> String
generateRecordEncoder varName fields allTypes =
    let
        fieldEncoders = Array.map (generateFieldEncoder varName allTypes) fields
        
        fieldPairs = Array.map (\encoder_ ->
            "        " ++ encoder_
        ) fieldEncoders
        
        joinedFields = String.join ",\n" fieldPairs
    in
    "Json.Encode.object\n" ++
    "        [\n" ++ joinedFields ++ "\n" ++
    "        ]"


generateFieldEncoder : String -> Array ParsedType -> RecordField -> String
generateFieldEncoder parentVar allTypes field =
    let
        fieldAccess = parentVar ++ "." ++ field.name
        encoder_ = generateTypeEncoder fieldAccess field.fieldType allTypes
    in
    "{ key = \"" ++ field.name ++ "\", value = " ++ encoder_ ++ " }"


generateTypeEncoder : String -> FieldType -> Array ParsedType -> String
generateTypeEncoder varName fieldType allTypes =
    when fieldType is
        StringType ->
            "Json.Encode.string " ++ varName
        
        IntType ->
            "Json.Encode.int " ++ varName
        
        FloatType ->
            "Json.Encode.float " ++ varName
        
        BoolType ->
            "Json.Encode.bool " ++ varName
        
        ArrayType innerType ->
            "Json.Encode.array (" ++ generateTypeEncoder "item" innerType allTypes ++ ") " ++ varName
        
        Parser.CustomFieldType typeName ->
            when Array.findFirst (\def -> def.name == typeName) allTypes is
                Just { value = typeDef } ->
                    when typeDef.definition is
                        TypeAlias aliasedType ->
                            generateTypeEncoder varName aliasedType allTypes
                        
                        RecordAlias fields ->
                            generateRecordEncoder varName fields allTypes
                        
                        CustomType _ ->
                            "encode" ++ typeName ++ " " ++ varName
                
                Nothing ->
                    "encode" ++ typeName ++ " " ++ varName
        
        Parser.RecordType fields ->
            generateRecordEncoder varName fields allTypes


generateCustomTypeEncoder : String -> Array CustomVariant -> Array ParsedType -> String
generateCustomTypeEncoder varName variants allTypes =
    let
        cases = Array.map (generateVariantCase allTypes) variants
        caseStrings = Array.map (\caseStr -> "        " ++ caseStr) cases
        joinedCases = String.join "\n" caseStrings
    in
    "when " ++ varName ++ " is\n" ++ joinedCases


generateVariantCase : Array ParsedType -> CustomVariant -> String
generateVariantCase allTypes variant =
    when variant.argument is
        Nothing ->
            variant.name ++ " ->\n" ++
            "            Json.Encode.string \"" ++ variant.name ++ "\""
        
        Just argType ->
            variant.name ++ " arg ->\n" ++
            "            Json.Encode.object\n" ++
            "                [ { key = \"tag\", value = Json.Encode.string \"" ++ variant.name ++ "\" }\n" ++
            "                , { key = \"value\", value = " ++ generateTypeEncoder "arg" argType allTypes ++ " }\n" ++
            "                ]"
