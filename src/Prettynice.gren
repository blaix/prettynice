module Prettynice exposing 
    ( Program
    , Init
    , defineProgram
    , startProgram
    )

 
{-| Full stack web framework for Gren.

This module mainly provides the functions to define and start your web server.
Prettynice also has the concept of client-side components, and other APIs for common web needs.
For an overview of full functionality, see [the project README](https://github.com/blaix/prettynice?tab=readme-ov-file#pretty-nice-framework),
the [documentation site](https://prettynice.dev),
or the [examples](https://github.com/blaix/prettynice/tree/main/examples).

-}

import FileSystem
import HttpServer as Http exposing (ServerError(..), Method(..))
import HttpServer.Response as HttpResponse 
import Init
import Node exposing (Environment, Program)
import Prettynice.Request exposing (Request)
import Prettynice.Response exposing (Response)
import Server.Static as Static exposing (Mode(..))
import Stream exposing (Stream)
import Task exposing (Task)
import Transmutable.Html as H
import Transmutable.Html.Attributes as A
import Url exposing (Url)


type alias Model appModel =
    { server : Maybe Http.Server
    , stdout : Stream
    , stderr : Stream
    , host : String
    , port_ : Int
    , env : Environment
    , fsPermission : FileSystem.Permission
    , appModel : appModel
    }


{-| The definition of your Prettynice program.
-}
type alias Program appModel appMsg =
    Node.Program (Model appModel) (Msg appModel appMsg)


{-| Init task for starting your Prettynice program.
-}
type alias Init appModel appMsg =
    Init.Task { model : Model appModel, command : Cmd (Msg appModel appMsg) }


{-| Define a Prettynice program.

Programs are defined similar to [regular gren node applications](https://gren-lang.org/book/applications/node/)
but with the addition of a `router` function that handles requests.
-}
defineProgram :
    { init : Environment -> Init appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> Program appModel appMsg
defineProgram app =
    Node.defineProgram
        { init = app.init
        , update = update { router = app.router, update = Just app.update }
        , subscriptions = subscriptions app.subscriptions
        }


{-| Start a Prettynice program that was defined with [defineProgram](#defineProgram).

This creates the init task you can return from your `init` function.

You can wrap this in an [Init.await/awaitTask](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Init#await)
if you need to run a task or initialize any subsystems before starting.
-}
startProgram :
    { host : String
    , port_ : Int
    , env : Environment
    , model : appModel
    , command : Cmd appMsg
    } -> Init appModel appMsg
startProgram config =
    Init.await Http.initialize <| \serverPermission ->
        Init.await FileSystem.initialize <| \fsPermission ->
            Node.startProgram
                { model =
                    { server = Nothing
                    , stdout = config.env.stdout
                    , stderr = config.env.stderr
                    , host = config.host
                    , port_ = config.port_
                    , env = config.env
                    , appModel = config.model
                    , fsPermission = fsPermission
                    }
                , command =
                    Cmd.batch
                        [ Cmd.map MsgToApp config.command
                        , Task.attempt CreateServerResult <|
                            Http.createServer serverPermission
                                { host = config.host
                                , port_ = config.port_
                                }
                        ]
                }


-- UPDATE


type Msg appModel appMsg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest Http.Request HttpResponse.Response
    | ResponseReady Response
    | MsgToApp appMsg


type alias AppUpdate appModel appMsg =
    appMsg -> appModel -> { model : appModel, command : Cmd appMsg }


update : 
    { router : appModel -> Request -> Response -> Task Never Response
    , update : Maybe (AppUpdate appModel appMsg)
    }
    -> Msg appModel appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
update appUpdate msg model =
    case msg of
        CreateServerResult result ->
            case result of
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stdout <|
                                "Server started on http://" ++ model.host ++ ":" ++ String.fromInt model.port_
                    }
                Err (ServerError code message) ->
                    { model = model
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stderr <|
                                "Server failed to start: " ++ code ++ "\n" ++ message
                    }
        
        GotRequest req res ->
            let
                request = 
                    Prettynice.Request.new req

                response =
                    Prettynice.Response.new res

                appResponseTask =
                    appUpdate.router model.appModel request response
                        |> logSuccess model.stdout req "sending to router"

                tryStaticResponse =
                    req.url
                        |> Static.response
                            { fileSystemPermission = model.fsPermission
                            , httpResponse = res
                            , directory = "./dist/client"
                            , mode = Normal
                            }
                        |> Task.map Prettynice.Response.new
                        |> logSuccess model.stdout req "sending static file"
            in
            { model = model
            , command =
                tryStaticResponse
                    |> Task.onError (\_ -> appResponseTask)
                    |> Task.perform ResponseReady
            }

        ResponseReady response ->
            { model = model
            , command = 
                response
                    |> Prettynice.Response.unwrap
                    |> HttpResponse.send
            }

        MsgToApp appMsg ->
            case appUpdate.update of
                Nothing ->
                    -- non-programs can't receive messages
                    { model = model
                    , command = Cmd.none
                    }

                Just up ->
                    let
                        appUpdateReturn =
                            up appMsg model.appModel
                    in
                    { model = { model | appModel = appUpdateReturn.model }
                    , command = Cmd.map MsgToApp appUpdateReturn.command
                    }


{-| Log a request with a custom message if task succeeds.
-}
logSuccess : Stream -> Http.Request -> String -> Task x a -> Task x a
logSuccess stream request message task =
    let
        printMsg =
            Http.requestInfo request ++ " : " ++ message
                |> Stream.sendLine stream
    in
    task
        |> Task.andThen
            (\a ->
                printMsg
                    |> Task.map (\_ -> a)
            )


-- SUBS


subscriptions : (appModel -> Sub appMsg) -> Model appModel -> Sub (Msg appModel appMsg)
subscriptions appSubs model =
    case model.server of
        Just server ->
            Sub.batch
                [ Http.onRequest server GotRequest
                , Sub.map MsgToApp <| appSubs model.appModel
                ]

        Nothing ->
            Sub.none
