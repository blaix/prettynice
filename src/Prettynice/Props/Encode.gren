module Prettynice.Props.Encode exposing (encoder)

import Json.Encode
import Prettynice.Props.Parser as Parser exposing (ParsedType, TypeDefinition(..), RecordField, CustomVariant, FieldType(..))


encoder : String -> String
encoder sourceCode =
    when Parser.parseTypeDefinitions sourceCode is
        Ok typeDefs ->
            when Parser.findPropsType typeDefs is
                Just propsType ->
                    generateEncoder propsType typeDefs

                Nothing ->
                    "-- No Props type found in: " ++ Debug.toString typeDefs

        Err deadEnds ->
            "-- Parse error: " ++ Debug.toString deadEnds


generateEncoder : ParsedType -> Array ParsedType -> String
generateEncoder propsType allTypes =
    let
        encoderName = "encodeProps"
        
        encoderBody = 
            when propsType.definition is
                TypeAlias aliasedType ->
                    generateTypeEncoder "props" aliasedType allTypes
                
                RecordAlias fields ->
                    generateRecordEncoder "props" fields allTypes
                
                CustomType variants ->
                    generateCustomTypeEncoder "props" variants allTypes
    in
    encoderName ++ " : Props -> Json.Encode.Value\n" ++
    encoderName ++ " props =\n" ++
    "    " ++ encoderBody


generateRecordEncoder : String -> Array RecordField -> Array ParsedType -> String
generateRecordEncoder varName fields allTypes =
    let
        fieldEncoders = Array.map (generateFieldEncoder varName allTypes) fields
        
        fieldPairs = Array.map (\encoder_ ->
            "        " ++ encoder_
        ) fieldEncoders
        
        joinedFields = String.join ",\n" fieldPairs
    in
    "Json.Encode.object\n" ++
    "        [\n" ++ joinedFields ++ "\n" ++
    "        ]"


generateFieldEncoder : String -> Array ParsedType -> RecordField -> String
generateFieldEncoder parentVar allTypes field =
    let
        fieldAccess = parentVar ++ "." ++ field.name
        encoder_ = generateTypeEncoder fieldAccess field.fieldType allTypes
    in
    "{ key = \"" ++ field.name ++ "\", value = " ++ encoder_ ++ " }"


generateTypeEncoder : String -> FieldType -> Array ParsedType -> String
generateTypeEncoder varName fieldType allTypes =
    when fieldType is
        StringType ->
            "Json.Encode.string " ++ varName
        
        IntType ->
            "Json.Encode.int " ++ varName
        
        FloatType ->
            "Json.Encode.float " ++ varName
        
        BoolType ->
            "Json.Encode.bool " ++ varName
        
        ArrayType innerType ->
            "Json.Encode.array (" ++ generateTypeEncoder "item" innerType allTypes ++ ") " ++ varName
        
        Parser.CustomFieldType typeName ->
            when Array.findFirst (\def -> def.name == typeName) allTypes is
                Just { value = typeDef } ->
                    when typeDef.definition is
                        TypeAlias aliasedType ->
                            generateTypeEncoder varName aliasedType allTypes
                        
                        RecordAlias fields ->
                            generateRecordEncoder varName fields allTypes
                        
                        CustomType _ ->
                            "encode" ++ typeName ++ " " ++ varName
                
                Nothing ->
                    "encode" ++ typeName ++ " " ++ varName
        
        Parser.RecordType fields ->
            generateRecordEncoder varName fields allTypes


generateCustomTypeEncoder : String -> Array CustomVariant -> Array ParsedType -> String
generateCustomTypeEncoder varName variants allTypes =
    let
        cases = Array.map (generateVariantCase allTypes) variants
        caseStrings = Array.map (\caseStr -> "        " ++ caseStr) cases
        joinedCases = String.join "\n" caseStrings
    in
    "when " ++ varName ++ " is\n" ++ joinedCases


generateVariantCase : Array ParsedType -> CustomVariant -> String
generateVariantCase allTypes variant =
    when variant.argument is
        Nothing ->
            variant.name ++ " ->\n" ++
            "            Json.Encode.string \"" ++ variant.name ++ "\""
        
        Just argType ->
            variant.name ++ " arg ->\n" ++
            "            Json.Encode.object\n" ++
            "                [ { key = \"tag\", value = Json.Encode.string \"" ++ variant.name ++ "\" }\n" ++
            "                , { key = \"value\", value = " ++ generateTypeEncoder "arg" argType allTypes ++ " }\n" ++
            "                ]"
