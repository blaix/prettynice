module Prettynice exposing 
    ( Program
    , Init
    , defineProgram
    , defineFullProgram
    , defineFullProgramRecord
    , startProgram
    , startFullProgram
    , startFullProgramRecord
    )

 
{-| Define and start a Prettynice web server.

@docs Program, defineProgram, Init, startProgram

## Messages, Commands, and Subscriptions

Sometimes `init` and `router` are not enough.
Maybe you need access to [commands](https://gren-lang.org/book/applications/commands/)
or [ports](https://gren-lang.org/book/applications/ports/#node-ports) on the server side.
If so, you can use these functions to create a program that includes `update` and `subscriptions`.

@docs defineFullProgram, startFullProgram

## More Control

If you want total control over how your app is defined and started,
or guarantees that Prettynice only has access to the subsystem permissions you provide,
you can use these functions to define your own records to pass to
[Node.defineProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#defineProgram)
and [Node.startProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#startProgram)
yourself.

@docs defineFullProgramRecord, startFullProgramRecord

-}

import Bytes exposing (Bytes)
import FileSystem
import HttpServer as Http exposing (ServerError(..), Method(..))
import HttpServer.Response as HttpResponse 
import Init
import Node exposing (Environment, Program)
import Prettynice.Request exposing (Request)
import Prettynice.Response exposing (Response)
import Server.Static as Static exposing (Mode(..))
import Stream
import Task exposing (Task)
import Transmutable.Html as H
import Transmutable.Html.Attributes as A
import Url exposing (Url)


type alias Model appModel =
    { server : Maybe Http.Server
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , host : String
    , port_ : Int
    , env : Environment
    , fsPermission : FileSystem.Permission
    , appModel : appModel
    }


{-| The definition of your Prettynice program.
-}
type alias Program appModel appMsg =
    Node.Program (Model appModel) (Msg appModel appMsg)


{-| Init task for starting your Prettynice program.
-}
type alias Init appModel appMsg =
    Init.Task { model : Model appModel, command : Cmd (Msg appModel appMsg) }

{-| Define a Prettynice web server.

Servers are defined with two functions:

* `init`: Will be passed [`Node.Environment`](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#Environment)
  and should return an [init task](#Init) created with [`startProgram`](#startProgram) or [`startFullProgram`](#startFullProgram).
* `router`: Will be called for every HTTP request. It will be passed the model you
  initiated in `init`, a [request](Prettynice.Request#Request),
  and a [response](#Prettynice.Response#Response). It should return a task always
  resolved to a response. See the [Response module](Response) for how you can
  customize the response.

See the [examples folder](https://github.com/blaix/prettynice/tree/main/examples)
for usage examples.
-}
defineProgram :
    { init : Environment -> Init appModel appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> Program appModel appMsg
defineProgram app =
    Node.defineProgram <|
        defineFullProgramRecord <|
            { init = app.init
            , router = app.router
            , update = (\_ model -> { model = model, command = Cmd.none })
            , subscriptions = (\_ -> Sub.none)
            }

{-| Define a Prettynice web server that uses the full Elm Architecture.

This is the same as [`defineProgram`](#defineProgram), but with the addition of
`update` and `subscription` functions. They work just like they do in a normal
[Gren node program](https://gren-lang.org/book/applications/node/#lets-make-a-web-server).

You should only need this if your server needs access to
[commands](https://gren-lang.org/book/applications/commands/)
(e.g. for [server-side ports](https://gren-lang.org/book/applications/ports/#node-ports))
or [subscriptions](https://gren-lang.org/book/applications/subscriptions/).
If you don't need them, you probably want [`defineProgram`](#defineProgram).
-}
defineFullProgram :
    { init : Environment -> Init appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> Program appModel appMsg
defineFullProgram app =
    Node.defineProgram <|
        defineFullProgramRecord app


{-| Create a record that can be passed to
[Node.defineProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#defineProgram)
to define a Prettynice program. For example:

    main =
        Node.defineProgram <|
            Prettynice.defineFullProgramRecord
                { init = init
                , update = update
                , subscriptions = subscriptions
                , router = router
                }

This is a more explicit alternative to (defineFullProgram)[#defineFullProgram].
-}
defineFullProgramRecord :    
    { init : Environment -> Init appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> 
    { init : Environment -> Init appModel appMsg
    , update : Msg appModel appMsg -> Model appModel -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
    , subscriptions : Model appModel -> Sub (Msg appModel appMsg)
    }
defineFullProgramRecord app =
    { init = app.init
    , update = update { router = app.router, update = app.update }
    , subscriptions = subscriptions app.subscriptions
    }


{-| Start a Prettynice web server.

This creates the init task that you return from your `init` function.

It takes a record with the following fields:

* env: The [Node.Environment](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#Environment)
  that is passed to your `init` function. (Prettynice needs this for the stdio streams).
* host: The name of the host to start your server on (e.g. "localhost").
* port_: The port number to start your server on
  (you should usually choose an integer over 1024, e.g. 3000).
* model: The initial value for your model. This will be passed to your `router` on every request.
  And if you are using `defineFullProgram`, it will be passed to your `update` function as well.
  If you don't need it, just set it to `{}`.

Example:

    init env =
        startProgram
            { env = env
            , host = "localhost"
            , port_ = 3000
            , model = {}
            }

You can wrap `startProgram` in one or more calls to
[Init.await/awaitTask](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Init#await)
if you need to run a task or initialize any subsystems before starting.
For example, maybe you need a
[`HttpClient.Permission`](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/HttpClient#Permission)
to save to your model so your router can make HTTP calls to a remote database
([example](https://github.com/blaix/prettynice/tree/v3/examples/v3/database)).

If you are using [`defineFullProgram`](#defineFullProgram) and want to include a
command as part of your init, you can use [`startFullProgram`](#startFullProgram)
instead.

If you don't want Prettynice to start your program for you,
or you want more control over how your program is started,
see (`startFullProgramRecord`)[#startFullProgramRecord].
-}
startProgram :
    { env : Environment
    , host : String
    , port_ : Int
    , model : appModel
    } -> Init appModel appMsg
startProgram config =
    startFullProgram
        { host = config.host
        , port_ = config.port_
        , env = config.env
        , model = config.model
        , command = Cmd.none
        }


{-| Start a Prettynice web server that includes an init command.

This works just like [`startProgram`](#startProgram) with the addition of a command
field to send a [command](https://gren-lang.org/book/applications/commands/) on init.
-}
startFullProgram :
    { env : Environment
    , host : String
    , port_ : Int
    , model : appModel
    , command : Cmd appMsg
    } -> Init appModel appMsg
startFullProgram  config =
    Init.await Http.initialize <| \serverPermission ->
    Init.await FileSystem.initialize <| \fsPermission ->
        Node.startProgram <|
            startFullProgramRecord
                { env = config.env
                , host = config.host
                , port_ = config.port_
                , model = config.model
                , command = config.command
                , permissions =
                    { fileSystem = fsPermission
                    , server = serverPermission
                    }
                }


{-| Create a record that can be passed to [Node.startProgram](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#startProgram)
to start a Prettynice program. For example:


    init env =
        Init.await FilesSystem.initialize <| \fsPermission ->
        Init.await HttpServer.initialize <| \serverPermission ->
            Node.startProgram <|
                Prettynice.startFullProgramRecord
                    { env = env
                    , host = "localhost"
                    , port_ = 3000
                    , model = {}
                    , command = Cmd.none
                    , permissions =
                        { server = serverPermission
                        , fileSystem = fsPermission
                        }
                    }


This is a more explicit alternative to (startFullProgram)[#startFullProgram]
and a way to guarantee Prettynice only has access to the subsystems you are
explicitly providing.
-}
startFullProgramRecord :
    { host : String
    , port_ : Int
    , env : Environment
    , model : appModel
    , command : Cmd appMsg
    , permissions :
        { fileSystem : FileSystem.Permission
        , server : Http.Permission
        }
    } ->
    { model : Model appModel
    , command : Cmd (Msg appModel appMsg)
    }
startFullProgramRecord config =
    { model =
        { server = Nothing
        , stdout = config.env.stdout
        , stderr = config.env.stderr
        , host = config.host
        , port_ = config.port_
        , env = config.env
        , appModel = config.model
        , fsPermission = config.permissions.fileSystem
        }
    , command =
        Cmd.batch
            [ Cmd.map MsgToApp config.command
            , Task.attempt CreateServerResult <|
                Http.createServer config.permissions.server
                    { host = config.host
                    , port_ = config.port_
                    }
            ]
    }


-- UPDATE


type Msg appModel appMsg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest { request : Http.Request, response : HttpResponse.Response }
    | ResponseReady Response
    | MsgToApp appMsg


makeGotRequestMsg : Http.Request -> HttpResponse.Response -> Msg appModel appMsg
makeGotRequestMsg request response =
    GotRequest
        { request = request
        , response = response
        }


type alias AppUpdate appModel appMsg =
    appMsg -> appModel -> { model : appModel, command : Cmd appMsg }


update : 
    { router : appModel -> Request -> Response -> Task Never Response
    , update : AppUpdate appModel appMsg
    }
    -> Msg appModel appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
update appUpdate msg model =
    when msg is
        CreateServerResult result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        print model.stdout <|
                            "Server started on http://" ++ model.host ++ ":" ++ String.fromInt model.port_
                    }
                Err (ServerError { code, message }) ->
                    { model = model
                    , command = 
                        print model.stderr <|
                            "Server failed to start: " ++ code ++ "\n" ++ message
                    }
        
        GotRequest { request = req, response = res } ->
            let
                request = 
                    Prettynice.Request.new req

                response =
                    Prettynice.Response.new res

                appResponseTask =
                    appUpdate.router model.appModel request response
                        |> logSuccess model.stdout req "sending to router"

                tryStaticResponse =
                    req.url
                        |> Static.response
                            { fileSystemPermission = model.fsPermission
                            , httpResponse = res
                            , directory = "./dist/client"
                            , mode = Normal
                            }
                        |> Task.map Prettynice.Response.new
                        |> logSuccess model.stdout req "sending static file"
            in
            { model = model
            , command =
                tryStaticResponse
                    |> Task.onError (\_ -> appResponseTask)
                    |> Task.perform ResponseReady
            }

        ResponseReady response ->
            { model = model
            , command = 
                response
                    |> Prettynice.Response.unwrap
                    |> HttpResponse.send
            }

        MsgToApp appMsg ->
            let
                appUpdateReturn =
                    appUpdate.update appMsg model.appModel
            in
            { model = { model | appModel = appUpdateReturn.model }
            , command = Cmd.map MsgToApp appUpdateReturn.command
            }


{-| Log a request with a custom message if task succeeds.
-}
logSuccess : Stream.Writable Bytes -> Http.Request -> String -> Task x a -> Task x a
logSuccess stream request message task =
    let
        fullMessage =
            Http.requestInfo request ++ " : " ++ message

        printMsg =
            Stream.writeLineAsBytes fullMessage stream
                |> Task.onError (\_ -> Task.succeed stream)
    in
    task
        |> Task.andThen
            (\a ->
                printMsg
                    |> Task.map (\_ -> a)
            )


-- SUBS


subscriptions : (appModel -> Sub appMsg) -> Model appModel -> Sub (Msg appModel appMsg)
subscriptions appSubs model =
    when model.server is
        Just server ->
            Sub.batch
                [ Http.onRequest server makeGotRequestMsg
                , Sub.map MsgToApp <| appSubs model.appModel
                ]

        Nothing ->
            Sub.none


-- UTIL


print : Stream.Writable Bytes -> String -> Cmd (Msg appModel appMsg)
print stream string =
    Stream.writeLineAsBytes string stream
        |> Task.onError (\_ -> Task.succeed stream)
        |> Task.execute
