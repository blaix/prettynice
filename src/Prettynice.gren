module Prettynice exposing 
    ( Program
    , Init

    -- Define your program
    , defineSimpleRouter
    , defineRouter
    , defineProgram

    -- Start your program
    , startSimpleRouter
    , startRouter
    , startProgram
    )

 
{-| Full stack web framework for Gren.

Programs are defined similar to [regular gren node applications](https://gren-lang.org/book/applications/node/)
but with the addition of a `router` function that handles requests.

There are three ways to define your program:

* [`defineSimpleRouter`](#defineSimpleRouter): When you only need to respond to requests without any tasks or server-side state.
* [`defineRouter`](#defineRouter): similar to the above, but lets you resolve server-side tasks before sending a response. So you can interact with the fileystem, network, databases, etc.
* [`defineProgram`](#defineProgram): similar to the above, but gives you access to the full [Elm Architecture](https://gren-lang.org/book/applications/tea/) with server-side state and event handling.

Migrating your application from one level to another is mostly additive, so choose the version that works for your simplest use case to get started.

(TODO: update examples to include the three types of programs and link to them here.)

-}

import FileSystem
import HttpServer as Http exposing (ServerError(..), Method(..))
import HttpServer.Response as HttpResponse 
import Init
import Node exposing (Environment, Program)
import Prettynice.Request exposing (Request)
import Prettynice.Response exposing (Response)
import Server.Static as Static exposing (Mode(..))
import Stream exposing (Stream)
import Task exposing (Task)
import Transmutable.Html as H
import Transmutable.Html.Attributes as A
import Url exposing (Url)


type alias Model appModel =
    { server : Maybe Http.Server
    , stdout : Stream
    , stderr : Stream
    , host : String
    , port_ : Int
    , env : Environment
    , fsPermission : FileSystem.Permission
    , appModel : appModel
    }


-- DEFINITIONS


{-| The definition of your Prettynice program.
-}
type alias Program appModel appMsg =
    Node.Program (Model appModel) (Msg appModel appMsg)


{-| Init task for starting your Prettynice program.
-}
type alias Init appModel appMsg =
    Init.Task { model : Model appModel, command : Cmd (Msg appModel appMsg) }


{-| Define a simple router for responding to requests.

The router is stateless and cannot trigger effects.

TODO: link to example
-}
defineSimpleRouter :
    { init : Environment -> Init {} {}
    , router : Request -> Response -> Response
    } -> Program {} {}
defineSimpleRouter app =
    let
        router _ request response =
            app.router request response
                |> Task.succeed
    in
    defineRouter 
        { init = app.init
        , router = router
        }


{-| Define a router that can depend on tasks.

TODO: link to example
-}
defineRouter :
    { init : Environment -> Init appModel {}
    , router : appModel -> Request -> Response -> Task Never Response
    } -> Program appModel {}
defineRouter app =
    Node.defineProgram
        { init = app.init
        , update = update { router = app.router, update = Nothing }
        , subscriptions = subscriptions (\_ -> Sub.none)
        }


{-| Define a Prettynice program.

If you don't need the full model/update/view cycle,
you probably want a [router](#defineRouter) or [simple router](#defineSimpleRouter) instead.

TODO: link to example
-}
defineProgram :
    { init : Environment -> Init appModel appMsg
    , update : appMsg -> appModel -> { model : appModel, command : Cmd appMsg }
    , subscriptions : appModel -> Sub appMsg
    , router : appModel -> Request -> Response -> Task Never Response
    } -> Program appModel appMsg
defineProgram app =
    Node.defineProgram
        { init = app.init
        , update = update { router = app.router, update = Just app.update }
        , subscriptions = subscriptions app.subscriptions
        }


-- STARTUP

{-| Start a simple router that was defined with [defineSimpleRouter](#defineSimpleRouter).

This creates the init task you can return from your `init` function.

TODO: link to example
-}
startSimpleRouter :
   { host : String
   , port_ : Int
   , env : Environment
   } -> Init {} {}
startSimpleRouter config =
    startRouter
        { host = config.host
        , port_ = config.port_
        , env = config.env
        , model = {}
        }

{-| Start a router that was defined with [defineRouter](#defineRouter).

This creates the init task you can return from your `init` function.

You can wrap this in an [Init.await/awaitTask](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Init#await)
if you need to run a task or initialize any subsystems before starting.

TODO: link to example
-}
startRouter :
   { host : String
   , port_ : Int
   , env : Environment
   , model : model
   } -> Init model {}
startRouter config =
    Init.await Http.initialize <| \serverPermission ->
        Init.await FileSystem.initialize <| \fsPermission ->
            Node.startProgram
                { model =
                    { server = Nothing
                    , stdout = config.env.stdout
                    , stderr = config.env.stderr
                    , host = config.host
                    , port_ = config.port_
                    , env = config.env
                    , fsPermission = fsPermission
                    , appModel = config.model
                    }
                , command =
                    Task.attempt CreateServerResult <|
                        Http.createServer serverPermission
                            { host = config.host
                            , port_ = config.port_
                            }
                }


{-| Start your program that was defined with [defineProgram](#defineProgram).

This creates the init task you can return from your `init` function.

You can wrap this in an [Init.await/awaitTask](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Init#await)
if you need to run a task or initialize any subsystems before starting.

TODO: link to example
-}
startProgram :
    { host : String
    , port_ : Int
    , env : Environment
    , model : appModel
    , command : Cmd appMsg
    } -> Init appModel appMsg
startProgram config =
    Init.await Http.initialize <| \serverPermission ->
        Init.await FileSystem.initialize <| \fsPermission ->
            Node.startProgram
                { model =
                    { server = Nothing
                    , stdout = config.env.stdout
                    , stderr = config.env.stderr
                    , host = config.host
                    , port_ = config.port_
                    , env = config.env
                    , appModel = config.model
                    , fsPermission = fsPermission
                    }
                , command =
                    Cmd.batch
                        [ Cmd.map MsgToApp config.command
                        , Task.attempt CreateServerResult <|
                            Http.createServer serverPermission
                                { host = config.host
                                , port_ = config.port_
                                }
                        ]
                }


-- UPDATE


type Msg appModel appMsg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest Http.Request HttpResponse.Response
    | ResponseReady Response
    | MsgToApp appMsg


type alias AppUpdate appModel appMsg =
    appMsg -> appModel -> { model : appModel, command : Cmd appMsg }


update : 
    { router : appModel -> Request -> Response -> Task Never Response
    , update : Maybe (AppUpdate appModel appMsg)
    }
    -> Msg appModel appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appModel appMsg) }
update appUpdate msg model =
    case msg of
        CreateServerResult result ->
            case result of
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stdout <|
                                "Server started on http://" ++ model.host ++ ":" ++ String.fromInt model.port_
                    }
                Err (ServerError code message) ->
                    { model = model
                    , command = 
                        Task.execute <|
                            Stream.sendLine model.stderr <|
                                "Server failed to start: " ++ code ++ "\n" ++ message
                    }
        
        GotRequest req res ->
            let
                request = 
                    Prettynice.Request.new req

                response =
                    Prettynice.Response.new res

                appResponseTask =
                    appUpdate.router model.appModel request response
                        |> logSuccess model.stdout req "sending to router"

                tryStaticResponse =
                    req.url
                        |> Static.response
                            { fileSystemPermission = model.fsPermission
                            , httpResponse = res
                            , directory = "./dist/client"
                            , mode = Normal
                            }
                        |> Task.map Prettynice.Response.new
                        |> logSuccess model.stdout req "sending static file"
            in
            { model = model
            , command =
                tryStaticResponse
                    |> Task.onError (\_ -> appResponseTask)
                    |> Task.perform ResponseReady
            }

        ResponseReady response ->
            { model = model
            , command = 
                response
                    |> Prettynice.Response.unwrap
                    |> HttpResponse.send
            }

        MsgToApp appMsg ->
            case appUpdate.update of
                Nothing ->
                    -- non-programs can't receive messages
                    { model = model
                    , command = Cmd.none
                    }

                Just up ->
                    let
                        appUpdateReturn =
                            up appMsg model.appModel
                    in
                    { model = { model | appModel = appUpdateReturn.model }
                    , command = Cmd.map MsgToApp appUpdateReturn.command
                    }


{-| Log a request with a custom message if task succeeds.
-}
logSuccess : Stream -> Http.Request -> String -> Task x a -> Task x a
logSuccess stream request message task =
    let
        printMsg =
            Http.requestInfo request ++ " : " ++ message
                |> Stream.sendLine stream
    in
    task
        |> Task.andThen
            (\a ->
                printMsg
                    |> Task.map (\_ -> a)
            )


-- SUBS


subscriptions : (appModel -> Sub appMsg) -> Model appModel -> Sub (Msg appModel appMsg)
subscriptions appSubs model =
    case model.server of
        Just server ->
            Sub.batch
                [ Http.onRequest server GotRequest
                , Sub.map MsgToApp <| appSubs model.appModel
                ]

        Nothing ->
            Sub.none
