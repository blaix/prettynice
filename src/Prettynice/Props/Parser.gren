module Prettynice.Props.Parser exposing 
    ( ParsedType
    , TypeDefinition(..)
    , RecordField
    , CustomVariant
    , parseTypes
    , findPropsType
    )

import Parser exposing (..)
import Set


type alias ParsedType =
    { name : String
    , definition : TypeDefinition
    }


type TypeDefinition
    = StringType
    | IntType
    | FloatType
    | BoolType
    | ArrayType TypeDefinition
    | RecordType (Array RecordField)
    | TypeAlias { name : String, definition : TypeDefinition }
    | CustomType { name : String, variants : Array CustomVariant }
    | CustomTypeRef String


type alias RecordField =
    { name : String
    , fieldType : TypeDefinition
    }


type alias CustomVariant =
    { name : String
    , argument : Maybe TypeDefinition
    }


createTypeAlias : String -> TypeDefinition -> ParsedType
createTypeAlias name typeDefinition =
    { name = name
    , definition = TypeAlias { name = name, definition = typeDefinition }
    }


createRecordField : String -> TypeDefinition -> RecordField
createRecordField name fieldType =
    { name = name, fieldType = fieldType }


createCustomType : String -> Array CustomVariant -> ParsedType
createCustomType name variants =
    { name = name
    , definition = CustomType { name = name, variants = variants }
    }


createCustomVariant : String -> Maybe TypeDefinition -> CustomVariant
createCustomVariant name argument =
    { name = name, argument = argument }


parseTypes : String -> Result (Array DeadEnd) (Array ParsedType)
parseTypes source =
    run (parseTypesHelper []) source


parseTypesHelper : Array ParsedType -> Parser (Array ParsedType)  
parseTypesHelper acc =
    oneOf
        [ succeed identity
            |. spaces
            |= typeParser
            |> andThen 
                (\def -> 
                    parseTypesHelper (Array.pushLast def acc)
                )
        , succeed acc
        ]


typeParser : Parser ParsedType
typeParser =
    oneOf
        [ typeAliasParser |> backtrackable
        , customTypeParser
        ]


typeAliasParser : Parser ParsedType
typeAliasParser =
    succeed createTypeAlias
        |. spaces
        |. keyword "type"
        |. spaces
        |. keyword "alias"
        |. spaces
        |= variableParser
        |. spaces
        |. symbol "="
        |. spaces
        |= typeDefinitionParser


customTypeParser : Parser ParsedType
customTypeParser =
    succeed createCustomType
        |. spaces
        |. keyword "type"
        |. spaces
        |= variableParser
        |. spaces
        |. symbol "="
        |. spaces
        |= customTypeVariantsParser


typeDefinitionParser : Parser TypeDefinition
typeDefinitionParser =
    lazy (\_ ->
        oneOf
            [ succeed StringType |. keyword "String"
            , succeed IntType |. keyword "Int"
            , succeed FloatType |. keyword "Float"
            , succeed BoolType |. keyword "Bool"
            , arrayTypeParser
            , recordTypeParser
            , customTypeRefParser
            ]
    )


recordFieldsSequenceParser : Parser (Array RecordField)
recordFieldsSequenceParser =
    sequence
        { start = ""
        , separator = ","
        , end = "}"
        , spaces = spaces
        , item = recordFieldParser
        , trailing = Optional
        }


variableParser : Parser String
variableParser =
    variable
        { start = Char.isAlpha
        , inner = \c -> Char.isAlphaNum c || c == '_'
        , reserved = Set.empty
        }


arrayTypeParser : Parser TypeDefinition
arrayTypeParser =
    succeed ArrayType
        |. keyword "Array"
        |. spaces
        |= typeDefinitionParser


recordTypeParser : Parser TypeDefinition
recordTypeParser =
    succeed RecordType
        |. symbol "{"
        |. spaces
        |= recordFieldsSequenceParser


customTypeRefParser : Parser TypeDefinition
customTypeRefParser =
    succeed CustomTypeRef |= variableParser


recordFieldParser : Parser RecordField
recordFieldParser =
    succeed createRecordField
        |= variableParser
        |. spaces
        |. symbol ":"
        |. spaces
        |= typeDefinitionParser


customTypeVariantsParser : Parser (Array CustomVariant)
customTypeVariantsParser =
    succeed (\first rest -> Array.pushFirst first rest)
        |. spaces
        |= customVariantParser
        |= parseRestVariants []


parseRestVariants : Array CustomVariant -> Parser (Array CustomVariant)
parseRestVariants acc =
    oneOf
        [ succeed (\variant -> parseRestVariants (Array.pushLast variant acc))
            |. chompWhile (\c -> c == ' ' || c == '\t')
            |. symbol "|"
            |. spaces
            |= customVariantParser
            |> andThen identity
        , succeed acc
        ]


customVariantParser : Parser CustomVariant
customVariantParser =
    succeed createCustomVariant
        |= variableParser
        |= parseOptionalArgument


parseOptionalArgument : Parser (Maybe TypeDefinition)
parseOptionalArgument =
    oneOf
        [ succeed Just
            |. chompIf (\c -> c == ' ' || c == '\t')
            |. chompWhile (\c -> c == ' ' || c == '\t')
            |= typeDefinitionParser
            |> backtrackable
        , succeed Nothing
        ]


findPropsType : Array ParsedType -> Maybe ParsedType
findPropsType typeDefs =
    Array.findFirst (\def -> def.name == "Props") typeDefs
        |> Maybe.map .value
