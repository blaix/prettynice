module Prettynice.Props.Encode exposing (encoder)

import Json.Encode
import Prettynice.Props.Parser as Parser exposing (ParsedType, TypeDefinition(..), RecordField, CustomVariant)


encoder : String -> String
encoder sourceCode =
    when Parser.parseTypes sourceCode is
        Ok typeDefs ->
            when Parser.findPropsType typeDefs is
                Just propsType ->
                    let
                        referencedTypes = findReferencedTypes propsType.definition typeDefs
                        allEncoders = Array.map (generateEncoder_ typeDefs) (Array.pushFirst propsType referencedTypes)
                        encoderStrings = Array.map (\encoder_ -> encoder_ ++ "\n\n") allEncoders
                    in
                    String.join "" encoderStrings

                Nothing ->
                    "-- No Props type found in: " ++ Debug.toString typeDefs

        Err deadEnds ->
            "-- Parse error: " ++ Debug.toString deadEnds


generateEncoder_ : Array ParsedType -> ParsedType -> String
generateEncoder_ allTypes parsedType =
    let
        encoderName = "encode" ++ parsedType.name
        typeName = parsedType.name
        
        encoderBody = 
            when parsedType.definition is
                TypeAlias { definition } ->
                    generateTypeDefinitionEncoder (String.toLower typeName) definition allTypes
                
                CustomType { variants } ->
                    generateCustomTypeEncoder (String.toLower typeName) variants allTypes
                
                _ ->
                    generateTypeDefinitionEncoder (String.toLower typeName) parsedType.definition allTypes
    in
    encoderName ++ " : " ++ typeName ++ " -> Json.Encode.Value\n" ++
    encoderName ++ " " ++ String.toLower typeName ++ " =\n" ++
    "    " ++ encoderBody


findReferencedTypes : TypeDefinition -> Array ParsedType -> Array ParsedType
findReferencedTypes typeDefinition allTypes =
    let
        referencedTypeNames = collectTypeNames typeDefinition
        findTypeByName name = Array.findFirst (\def -> def.name == name) allTypes |> Maybe.map .value
    in
    Array.foldl (\name acc ->
        when findTypeByName name is
            Just foundType -> Array.pushLast foundType acc
            Nothing -> acc
    ) [] referencedTypeNames


collectTypeNames : TypeDefinition -> Array String
collectTypeNames typeDefinition =
    when typeDefinition is
        StringType -> []
        IntType -> []
        FloatType -> []
        BoolType -> []
        ArrayType innerType -> collectTypeNames innerType
        RecordType fields ->
            Array.foldl (\field acc -> 
                Array.append acc (collectTypeNames field.fieldType)
            ) [] fields
        CustomTypeRef typeName -> [typeName]
        TypeAlias { definition } -> collectTypeNames definition
        CustomType { variants } ->
            Array.foldl (\variant acc ->
                when variant.argument is
                    Just argType -> Array.append acc (collectTypeNames argType)
                    Nothing -> acc
            ) [] variants


generateRecordEncoder : String -> Array RecordField -> Array ParsedType -> String
generateRecordEncoder varName fields allTypes =
    let
        fieldEncoders = Array.map (generateFieldEncoder varName allTypes) fields
        
        fieldPairs = Array.map (\encoder_ ->
            "        " ++ encoder_
        ) fieldEncoders
        
        joinedFields = String.join ",\n" fieldPairs
    in
    "Json.Encode.object\n" ++
    "        [\n" ++ joinedFields ++ "\n" ++
    "        ]"


generateFieldEncoder : String -> Array ParsedType -> RecordField -> String
generateFieldEncoder parentVar allTypes field =
    let
        fieldAccess = parentVar ++ "." ++ field.name
        encoder_ = generateTypeDefinitionEncoder fieldAccess field.fieldType allTypes
    in
    "{ key = \"" ++ field.name ++ "\", value = " ++ encoder_ ++ " }"


generateTypeDefinitionEncoder : String -> TypeDefinition -> Array ParsedType -> String
generateTypeDefinitionEncoder varName typeDefinition allTypes =
    when typeDefinition is
        StringType ->
            "Json.Encode.string " ++ varName
        
        IntType ->
            "Json.Encode.int " ++ varName
        
        FloatType ->
            "Json.Encode.float " ++ varName
        
        BoolType ->
            "Json.Encode.bool " ++ varName
        
        ArrayType innerType ->
            "Json.Encode.array (" ++ generateTypeDefinitionEncoder "item" innerType allTypes ++ ") " ++ varName
        
        RecordType fields ->
            generateRecordEncoder varName fields allTypes
        
        CustomTypeRef typeName ->
            when Array.findFirst (\def -> def.name == typeName) allTypes is
                Just { value = parsedType } ->
                    when parsedType.definition is
                        TypeAlias { definition } ->
                            generateTypeDefinitionEncoder varName definition allTypes
                        
                        CustomType _ ->
                            "encode" ++ typeName ++ " " ++ varName
                        
                        _ ->
                            generateTypeDefinitionEncoder varName parsedType.definition allTypes
                
                Nothing ->
                    "encode" ++ typeName ++ " " ++ varName
        
        TypeAlias { definition } ->
            generateTypeDefinitionEncoder varName definition allTypes
        
        CustomType _ ->
            "-- Cannot encode custom type inline"


generateCustomTypeEncoder : String -> Array CustomVariant -> Array ParsedType -> String
generateCustomTypeEncoder varName variants allTypes =
    let
        cases = Array.map (generateVariantCase allTypes) variants
        caseStrings = Array.map (\caseStr -> "        " ++ caseStr) cases
        joinedCases = String.join "\n" caseStrings
    in
    "when " ++ varName ++ " is\n" ++ joinedCases


generateVariantCase : Array ParsedType -> CustomVariant -> String
generateVariantCase allTypes variant =
    when variant.argument is
        Nothing ->
            variant.name ++ " ->\n" ++
            "            Json.Encode.string \"" ++ variant.name ++ "\""
        
        Just argType ->
            variant.name ++ " arg ->\n" ++
            "            Json.Encode.object\n" ++
            "                [ { key = \"tag\", value = Json.Encode.string \"" ++ variant.name ++ "\" }\n" ++
            "                , { key = \"value\", value = " ++ generateTypeDefinitionEncoder "arg" argType allTypes ++ " }\n" ++
            "                ]"
